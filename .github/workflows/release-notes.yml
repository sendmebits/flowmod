name: Generate Release Notes

on:
  release:
    types: [published]

permissions:
  contents: write

jobs:
  generate-notes:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # full history so we can diff between tags

      - name: Build release notes from commits
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAG_NAME: ${{ github.event.release.tag_name }}
          RELEASE_ID: ${{ github.event.release.id }}
        run: |
          set -euo pipefail

          # â”€â”€ Find the previous release tag â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          PREV_TAG=$(git tag --sort=-creatordate | grep -v "^${TAG_NAME}$" | head -n 1 || true)

          if [ -z "$PREV_TAG" ]; then
            echo "No previous tag found â€” using all commits on the branch."
            RANGE="HEAD"
          else
            echo "Previous tag: $PREV_TAG"
            RANGE="${PREV_TAG}..${TAG_NAME}"
          fi

          # â”€â”€ Collect commits (hash + subject) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          COMMITS=$(git log "$RANGE" --pretty=format:"%H %s" --no-merges)

          if [ -z "$COMMITS" ]; then
            echo "No commits found in range."
            exit 0
          fi

          # â”€â”€ Categorize â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          FEATURES=""
          FIXES=""
          DOCS=""
          UI_UX=""
          PERF=""
          MAINTENANCE=""
          OTHER=""

          while IFS= read -r line; do
            SHA="${line%% *}"
            SHORT_SHA="${SHA:0:7}"
            MSG="${line#* }"

            # Normalize: lowercase for matching, preserve original for display
            MSG_LOWER=$(echo "$MSG" | tr '[:upper:]' '[:lower:]')
            # Strip conventional-commit prefix for cleaner display
            DISPLAY_MSG=$(echo "$MSG" | sed -E 's/^(feat|feature|fix|bugfix|hotfix|docs|doc|documentation|ui|ux|design|perf|performance|refactor|chore|build|ci|style|test)(\(.+\))?[:][ ]*//')
            ENTRY="- ${DISPLAY_MSG} (\`${SHORT_SHA}\`)"

            case "$MSG_LOWER" in
              feat:*|feat\(*|feature:*|feature\(*)
                FEATURES="${FEATURES}${ENTRY}\n" ;;
              fix:*|fix\(*|bugfix:*|bugfix\(*|hotfix:*|hotfix\(*)
                FIXES="${FIXES}${ENTRY}\n" ;;
              docs:*|docs\(*|doc:*|doc\(*|documentation:*)
                DOCS="${DOCS}${ENTRY}\n" ;;
              ui:*|ui\(*|ux:*|ux\(*|design:*|design\(*)
                UI_UX="${UI_UX}${ENTRY}\n" ;;
              perf:*|perf\(*|performance:*|performance\(*)
                PERF="${PERF}${ENTRY}\n" ;;
              refactor:*|refactor\(*|chore:*|chore\(*|build:*|build\(*|ci:*|ci\(*|style:*|style\(*|test:*|test\(*)
                MAINTENANCE="${MAINTENANCE}${ENTRY}\n" ;;
              *)
                # Keyword fallback for non-prefixed commits
                if echo "$MSG_LOWER" | grep -qE '(add|new|feature|implement|introduce)'; then
                  FEATURES="${FEATURES}${ENTRY}\n"
                elif echo "$MSG_LOWER" | grep -qE '(fix|bug|patch|resolve|crash|issue)'; then
                  FIXES="${FIXES}${ENTRY}\n"
                elif echo "$MSG_LOWER" | grep -qE '(doc|readme|comment|guide)'; then
                  DOCS="${DOCS}${ENTRY}\n"
                elif echo "$MSG_LOWER" | grep -qE '(ui|ux|layout|design|theme|icon|animation)'; then
                  UI_UX="${UI_UX}${ENTRY}\n"
                elif echo "$MSG_LOWER" | grep -qE '(perf|speed|fast|optim|cache)'; then
                  PERF="${PERF}${ENTRY}\n"
                elif echo "$MSG_LOWER" | grep -qE '(refactor|clean|rename|move|reorgan|chore|bump|update dep|maint)'; then
                  MAINTENANCE="${MAINTENANCE}${ENTRY}\n"
                else
                  OTHER="${OTHER}${ENTRY}\n"
                fi
                ;;
            esac
          done <<< "$COMMITS"

          # â”€â”€ Assemble the body â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          BODY=""

          append_section() {
            local title="$1" content="$2"
            if [ -n "$content" ]; then
              BODY="${BODY}## ${title}\n\n${content}\n"
            fi
          }

          append_section "ðŸš€ New Features"            "$FEATURES"
          append_section "ðŸ› Bug Fixes"                "$FIXES"
          append_section "ðŸŽ¨ UI/UX Improvements"       "$UI_UX"
          append_section "âš¡ Performance Improvements"  "$PERF"
          append_section "ðŸ“š Documentation"             "$DOCS"
          append_section "ðŸ”§ Maintenance"               "$MAINTENANCE"
          append_section "ðŸ“¦ Other Changes"             "$OTHER"

          if [ -z "$BODY" ]; then
            echo "Nothing to write."
            exit 0
          fi

          # Add compare link footer
          if [ -n "$PREV_TAG" ]; then
            REPO_URL="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}"
            BODY="${BODY}---\n**Full diff:** [${PREV_TAG}...${TAG_NAME}](${REPO_URL}/compare/${PREV_TAG}...${TAG_NAME})\n"
          fi

          # â”€â”€ Update the release body via GitHub API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          # Write body to a temp file to avoid shell escaping issues
          echo -e "$BODY" > /tmp/release_body.md
          gh release edit "$TAG_NAME" --notes-file /tmp/release_body.md
          echo "âœ… Release notes updated for $TAG_NAME"
